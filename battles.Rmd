---
title: "Game Of Thrones"
date: "15 de marzo de 2019"
output:
  html_document:
    df_print: paged 
    toc : true
    toc_float: 
      collapsed: false
    number_sections: true 
    theme: cosmo  
--- 
```{r setup, include=FALSE, warning=FALSE, error=FALSE}
knitr::opts_chunk$set(echo = TRUE, warning = FALSE)
```
Game of Thrones es un exitoso programa de televisión de fantasía basado en la serie de libros "A Song of Fire and Ice" de George RR Martin. El programa es bien conocido por su paisaje político enormemente complicado, su gran número de personajes y sus frecuentes muertes de personajes.

# Pregunta 1: ¿Hay alguna relación entre quién dirige la batalla y el resultado final de esta?
A veces, que un grupo gane en algo o no depende mucho del líder que tengan a su disposición. Con esta pregunta vamos a intentar comprobar si el rey y el commander de los ejércitos influye de alguna forma en el resultado final de la batalla. Al final compararemos cada uno de los commanders para averiguar cuál es el mejor de entre todas las batallas de los 5 Reinos. 

El dataset que vamos a utilizar para responder a esta pregunta es el conjunto de datos que recoge las batallas ocurridas en la serie, llamado "The War of the Five Kings" Dataset, que puede ser encontrado en [ https://github.com/chrisalbon/war_of_the_five_kings_dataset] 

```{r echo=FALSE, warning=FALSE}
# Cargar Librerías
library(ggplot2)
library(knitr)
library(tidyverse)

```

## Lectura de los datos
```{r}
datos = readxl::read_xlsx("data/battles.xlsx")
datos
```


## Preprocesamiento
### Valores nulos
¿Cuántos valores nulos hay de cada una de las columnas?
```{r}
na_count <-sapply(datos, function(y) sum(length(which(is.na(y)))))
na_count <- as.data.frame(na_count)
na_count["cols"] <- colnames(datos)
na_count <- na_count %>% arrange(desc(na_count))

ggplot(data=na_count, aes(x=cols, y=na_count, color = cols)) + 
    geom_bar(stat="identity", fill="white")  +coord_flip() + geom_hline(yintercept = 0.6*dim(datos)[1])
```

Ordenamos las columnas en base al número de valores nulos y vemos cuáles son las 5 columnas con más valores nulos:
```{r}
na_count[1:5,]

```
Como primer paso de preprocesamiento  eliminaremos aquellas columnas que tengan más de un 60% de valores NULOS. Si observamos la gráfica anterior se observa una línea que indica el 60 % de valores nulos
```{r}
datos_p1 <- datos[lapply( datos, function(x) sum(is.na(x)) / length(x) ) < 0.6]
datos_p1

```
Tras esta eliminación aún tenemos columnas con valores nulos, a continuación se explicarán cuáles han sido las decisiones a tomar:
* __attacker_king y defender_king__ : se cambiarán los valores nulos por "Without a king"
* __attacker_2, attacker_3, attacker_4 y defender_2__: son columnas que no hemos considerado de interés, solo el primer atacante y el primer defensor, por lo que serán eliminadas
* __defender_1__: se sustituirá el valor por "Pedestrians"
* __ major_death, major_capture, notes y summer__: columnas irrelevantes para responder a la pregunta, por lo tanto serán eliminadas
* __attacker_size__: los valores faltantes serán sustituidos por la media del tamaño del ejército para cada uno de los reyes
* __defender_size__: los valores faltantes serán sustituidos por la media del tamaño del ejército para cada uno de los reyes
* __attacker_commander y defender_commander__: estos valores serán sustitidos por "Without a commander"
* __location__: como se tiene la información de la región se optará por eliminar esta columna
* __attacker_outcome__: solo hay un valor nulo, por lo que se ha decidido buscar la información correspondiente [https://gameofthrones.fandom.com/wiki/Battle_of_Winterfell] y rellenar este dato

A continuación se muestra el código ncesario para llevar a cabo estas tareas:

```{r echo=TRUE, results='hide'}
#Sustituir valores nulos
datos_p2 <- datos_p1
datos_p2$attacker_king <- datos_p2$attacker_king %>% replace_na("Without a king")
datos_p2$defender_king <- datos_p2$defender_king %>% replace_na("Without a king")
datos_p2$defender_1 <- datos_p2$defender_1 %>% replace_na("Pedestrians")
datos_p2$attacker_commander <- datos_p2$attacker_commander %>% replace_na("Without a commander")
datos_p2$defender_commander <- datos_p2$defender_commander %>% replace_na("Without a commander")
datos_p2$attacker_outcome <- datos_p2$attacker_outcome %>% replace_na("loss")


```


```{r}
#sustituir los tamaños de los ejércitos por la media según el rey
datos_p2$attacker_size <- with(datos_p2, ave(attacker_size, attacker_king,
    FUN = function(x) replace(x, is.na(x), mean(x, na.rm = TRUE))))

datos_p2$defender_size <- with(datos_p2, ave(defender_size, defender_king,
    FUN = function(x) replace(x, is.na(x), mean(x, na.rm = TRUE))))
```

### Selección de atributos
```{r}
#Elegir sólo las culumnas de interés para nuestra pregunta
battle<-datos_p2 %>% select(name,year,attacker_king,defender_king,attacker_outcome,attacker_size,defender_size, attacker_commander, defender_commander)

```


```{r}
#Recoger solo el primer commander que aparezca en la lista
a <- c()

for (i in 1:length(battle$attacker_commander))
  a[i] = strsplit(battle$attacker_commander[i], ",")[[1]][1]
  
battle$attacker_commander <- a

```

```{r}
def <- c()

for (i in 1:length(battle$defender_commander))
  def[i] <- strsplit(battle$defender_commander[i], ",")[[1]][1]

battle$defender_commander <- def
```

## Visualización
### ¿Qué rey ha atacado más?
```{r}
g1 <- ggplot(aes(x = factor(attacker_king)), data = battle, fill=factor(attacker_king)) + 
    geom_bar(aes(fill=factor(attacker_king)), width=1, colour="black") +
    ggtitle("No de Batallas por rey") +
    xlab("Rey Atacante") + ylab("No de Batallas") + coord_flip()
print(g1)
```

### ¿Qué rey ha defendido más?
```{r}
g1 <- ggplot(aes(x = factor(defender_king)), data = battle, fill=factor(defender_king)) + 
    geom_bar(aes(fill=factor(defender_king)), width=1, colour="black") +
    ggtitle("No de Batallas por rey") +
    xlab("Rey Defensor") + ylab("No de Batallas") + coord_flip()
print(g1)
```
De estos dos gráficos podemos observar que Mance Rayder y Renly Baratheon sólo se han ocupado de defender sus terrenos, no se han preocupado por atacar a ninguno. Además también se observa que como en la serie, los que siempre están comprometidos en algo son los Baratheon y los Stark. 

### Reyes contra reyes
```{r, echo=FALSE, fig.height=5, fig.width=10, message=FALSE, warning=FALSE}
library(ggthemes)
g2 <- ggplot(data = battle, aes(x = defender_king,fill=attacker_outcome)) +
  geom_bar(width=0.5) +
  theme_tufte(base_size=14,ticks = F) +
  scale_fill_few()+
  geom_hline(yintercept=seq(0, max( table(battle$defender_king,battle$attacker_king)), 1), col="white", lwd=1)+
  scale_y_continuous(breaks=seq(0, max( table(battle$defender_king,battle$attacker_king)), 2))+
  facet_wrap(~ attacker_king)+coord_flip()+
  xlab("Rey Defensor") + ylab("Número de batallas")
print(g2)
```
Según el gráfico anterior parecer ser que las casas que están más enfrentadas son la Baratheon y la Stark, por lo tanto puede que el commander que más exito tenga sea uno perteneciente a una de estas casas, ya que el número de batallas es meyor y por lo tanto se tendrán más datos. Aún así, esto es solo una suposición, tendremos que indagar un poco más para poder contestar a la pregunta principal.


### Número de batallas ganadas por cada commander atacante
El siguiente paso será visualizar el número de batallas ganadas y perdidas para cada uno de los commanders, dependiendo de a qué rey sirvan.
```{r,  fig.width=10, fig.height=8}
g3 <- ggplot(data = battle, aes(x = attacker_commander,fill=attacker_outcome)) +
  geom_bar(width=0.5) +
  theme_tufte(base_size=14,ticks = F) +
  scale_fill_few()+
  geom_hline(yintercept=seq(0, 6, 1), col="white", lwd=1)+
  scale_y_continuous(breaks=seq(0, 6))+
  coord_flip()+
  xlab("Commander Atacante") + ylab("Número de batallas")
print(g3)
```

```{r}
robb <- subset(battle,attacker_commander=="Robb Stark")
gregor <- subset(battle, attacker_commander=="Gregor Clegane")
robb_gregor <- rbind(robb, gregor)
table(robb_gregor$attacker_commander, robb_gregor$attacker_king)
```

Como se dijo antes, parece ser que los dos commanders atacantes que tienen más prestigio y que han ganado más batallas están a las órdenes de los dos reinos que más se enfrentan entre ellos.

### Commanders atacantes y defensores
Hasta ahora solo se han tenido en cuenta los commanders atacantes, sin embargo, para poder sacar conclusiones hay que tener en cuenta también las batallas ganadas por los defensores.

```{r}
#Crear una lista con los valores unicos de commanders atacantes y defensores
attackers <- battle$attacker_commander
defenders <- battle$defender_commander

commanders <- unique(c(attackers, defenders))

```

1. El primer paso será contar el número de veces que un commander ha atacado satisfactoriamente:
```{r}
attack_win <- c()
for (i in 1:length(commanders)){
  win = 0
  for ( j in 1:length(battle$name)){
    if (battle$attacker_commander[j] == commanders[i] && battle$attacker_outcome[j]=="win"){
      win = win +1
    }else{
      win = win +0
    }
  }
  attack_win[i] <- win
}
  
attack_win_commander <- cbind(commanders, attack_win)
```

2. El segundo paso será contar el número de veces que un commander ha defendido satisfactoriamente:
```{r}
defend_win <- c()
for (i in 1:length(commanders)){
  win = 0
  for ( j in 1:length(battle$name)){
    #print(battle$defender_commander[j] == commanders[i] && battle$attacker_outcome!="win")
    if (battle$defender_commander[j] == commanders[i] && battle$attacker_outcome[j]!="win"){
      win = win +1
    }else{
      win = win +0
    }
  }
  defend_win[i] <- win
}
  
defend_win_commander <- cbind(commanders, defend_win)
```


3. El tercer paso será contar el número de veces que un atacante ha perdido la batalla
```{r}
attack_loss <- c()
for (i in 1:length(commanders)){
  loss = 0
  for ( j in 1:length(battle$name)){
    if (battle$attacker_commander[j] == commanders[i] && battle$attacker_outcome[j]!="win"){
      loss = loss +1
    }else{
      loss = loss +0
    }
  }
  attack_loss[i] <- loss
}
  
attack_loss_commander <- cbind(commanders, attack_loss)
```




4. El cuarto paso será contar el número de veces que un defensor ha perdido la batalla
```{r}
defend_loss <- c()
for (i in 1:length(commanders)){
  loss = 0
  for ( j in 1:length(battle$name)){
    if (battle$defender_commander[j] == commanders[i] && battle$attacker_outcome[j]=="win"){
      loss = loss +1
    }else{
      loss = loss +0
    }
  }
  defend_loss[i] <- loss
}
  
defend_loss_commander <- cbind(commanders, defend_loss)
```

Creamos un dataframe con los commanders y sus puntuaciones:
```{r}
battle_record <- cbind.data.frame(commanders, attack_win, attack_loss, defend_win, defend_loss)
```

```{r, fig.height=10}
library(gridExtra)
g1 <- ggplot(battle_record, aes(x=commanders, y = c(attack_win))) + geom_bar(stat="identity") + coord_flip() +theme_minimal()

g2 <- ggplot(battle_record, aes(x=commanders, y = c(attack_loss))) + geom_bar(stat="identity") + coord_flip() +theme_minimal() + theme(axis.text.y = element_blank(), axis.title.y =  element_blank()) 

g3 <- ggplot(battle_record, aes(x=commanders, y = c(defend_win))) + geom_bar(stat="identity") + coord_flip() +theme_minimal() + theme(axis.text.y = element_blank(), axis.title.y =  element_blank()) 

g4 <- ggplot(battle_record, aes(x=commanders, y = c(defend_loss))) + geom_bar(stat="identity") + coord_flip()+theme_minimal() + theme(axis.text.y = element_blank(), axis.title.y =  element_blank()) + ylim(0,1.5)

grid.arrange(g1, g2, g3, g4, ncol=4)


```

Por último, hemos definido un ratio que nos servirá para escoger qué commander es el mejor de entre todos los que hay, este índice consiste en el ratio entre las batallas ganadas (attack_win + deffend_win) y las batallas totales en las que ha participado.
```{r}
ratio <- c()
for (i in 1:length(battle_record$commanders)){
  f1 = battle_record$attack_win[i]/38
  f2 = battle_record$defend_win[i]/38

  ratio[i] = f1+f2
}

battle_record <- cbind.data.frame(battle_record, ratio)
#battle_record <- battle_record %>% arrange(desc(ratio))
```

```{r}
head(battle_record,4)
```

Como ya suponíamos desde un momento, el primer commander es Gregor Clegane